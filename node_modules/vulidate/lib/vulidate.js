/*!
* Vulidate.js v0.2.0
* (c) 2019 张帅
* Released under the MIT License.
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.vulidate = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function validate(rules, values) {
    if (Array.isArray(rules) && rules.length) {
      // exec in sequence
      return rules.slice(1).reduce(function (lastPromise, curentRule) {
        return lastPromise.then(function () {
          return validItem(curentRule, values);
        });
      }, validItem(rules[0], values));
    } else if (_typeof(rules) === 'object' && rules !== null) {
      return new Promise(function (resolve, reject) {
        var keys = Object.keys(rules);
        var errors = [];
        var finalLen = 0;
        var length = keys.length;
        keys.forEach(function (key) {
          validate(rules[key], values[key]).then(judge)["catch"](function (error) {
            errors.push(error);
            judge();
          });
        });

        function judge() {
          if (++finalLen === length) {
            // finally
            if (errors.length) {
              reject(errors);
            } else {
              resolve();
            }
          }
        }
      });
    } else {
      return Promise.resolve();
    }
  }

  function validItem(rule, value) {
    var result;
    var source = Object.assign({
      value: value
    }, rule);

    if (!rule.validator) {
      result = true;
    } else {
      // funciton validate
      result = rule.validator(value, source);
    } // thenable


    if (typeof result.then === 'function') {
      return result["catch"](function (reason) {
        var res = _objectSpread({}, source, {
          reason: reason
        });

        if (typeof reason === 'string') {
          res.message = reason;
        }

        throw res;
      });
    }

    return result ? Promise.resolve() : Promise.reject(source);
  }

  function createDecorator(rule) {
    if (!rule) {
      throw new Error('no rule provided');
    }

    if (typeof rule === 'function') {
      rule = {
        validator: rule
      };
    }

    return function appendDecorator(args) {
      var newRule;

      if (typeof args === 'string') {
        newRule = Object.assign({}, rule, {
          message: args || 'valid fail'
        });
      } else {
        newRule = Object.assign({}, rule, args);
      }

      return function decorator(target, property) {
        if (!target.__rules) {
          Object.defineProperty(target, '__rules', {
            enumerable: false,
            configurable: false,
            writable: false,
            value: Object.create(null)
          });
          Object.defineProperty(target, '$validate', {
            enumerable: false,
            configurable: false,
            writable: false,
            value: function $validate() {
              return validate(getRules(target), target);
            }
          });
        }

        if (target.__rules[property]) {
          target.__rules[property].push(newRule);
        } else {
          target.__rules[property] = [newRule];
        }
      };
    };
  }

  function getRules(val) {
    if (val && val.__rules) {
      var rules = Object.assign({}, val.__rules);
      Object.keys(val).forEach(function (k) {
        rules[k] = getRules(val[k]) || rules[k];
      });
      return rules;
    }
  }

  return createDecorator;

}));
